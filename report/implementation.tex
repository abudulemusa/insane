\chapter{Implementation}
\label{chap:implementation}
This tool has been implemented on the top of the Scala compiler, and can be
built as a plugin of the compiler. One of the main advantage of building it as
a compiler plugin is that it grants us immediate access to the trees and all
type information that we need. The compiler allows us to plug our tool between
two existing phases. Depending on where the plugin is inserted, it dramatically
changes the aspect of the trees. In this case, we decided to put it late in the
compilation process, so that we would not have to deal with closures, inner
classes, mixins, or genericity. This however comes with some cost: we lost
precision in the presence of parametric types, and the amount of code to
analyze is much bigger.

\section{Class Hierarchy}
The first implementation problem we faced while working with the Scala compiler
is that, it does not provide any way to access subtypes of one symbol, only its
super type. For this reason, we had to traverse every symbols defined in the
classpath in order to reconstruct the entire hierarchy, which allowed us to
compute subtypes. This process of traversing every defined symbols in the class
path is costly (minimum 30'000 symbols given that the Java and Scala library are always
included), and represented most of the analysis time for small examples.

For this reason, we decided to store the class hierarchy of the Scala and Java
libraries into a database. We use a nested
set\footnote{\url{http://dev.mysql.com/tech-resources/articles/hierarchical-data.html}}
representation for our hierarchical data, which allows us to retrieve the entire
set of subtypes in one SQL query efficiently.

\section{Graph Generation}
\subsection{Storing Intermediate Results}
Even though the analysis is meant to be run on the entire code, it remains
modular as each method is associated an effect graph. For this reason, we
analyzed the entire Scala library, which represents approximately 90'000
methods, and stored them in a database. This pre-calculation of the library is
key in order to analyze Scala applications without having to include the
source of the library. To store the results in the database, we had to
implement a special serialization procedure, as the objects used in the graphs
referenced internal compiler objects such as class symbols that were not
serializable via standard ways. Our custom serialization allows for full
recovery of the state, and is specific enough to be concise.

\subsection{Unanalyzable Methods}
One of the main problem that we faced while analyzing the Scala library is that
it referenced approximately 700 methods of the Java library, that our Scala
compiler can't analyze. Instead of making conservative assumptions and applying
\emph{havoc} on every objects involved in those various calls, we provided a way
for the user to provide Scala implementations of those classes and methods. This
is done via annotations put at the level of the classes and methods, that will
inform our compiler that this graph is meant to represent other methods. We
illustrate this in Figure~\ref{fig:imp:annotations}.
\begin{figure}[h]
    \centering
\begin{lstlisting}
class A {
  def test(obj: A) {
    obj.foo()
  }
  def foo() {
    println("A")
  }
}

class B extends A {
  override def foo() {
    println("B")
  }
}
\end{lstlisting}
    \caption{Annotations}
    \label{fig:imp:annotations}
\end{figure}
