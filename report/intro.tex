\chapter{Introduction} \label{chap:intro}
Pointer analysis is a static analysis technique that builds information on the
relations between pointers and allocated objects. It is also often referred to
as points-to or alias analysis.

In most object oriented languages such as Scala, the use of pointers is
overwhelming, rendering even basic static analys techniques brittle. It is thus
often necessary to establish information on the aliasing relations between
variables, as well as some knowledge of the shape of structures stored in the
heap.

Effect analysis tries to summarize the effects of procedures in a certain
domain. In this case, we focus on memory-based effects, and are thus interested
in computing a summary of read and write operations performed to object fields.
It is evident that such effect analysis requires on a good pointer analysis,
and vice-versa. For this reason, we perform both analyses side by side.

The summary of effects coupled with aliasing information can later be used to
perform various kinds of optimizations or enable more sophisticated analyses.
For instance, if we establish that two sequential operations affect disjoint
parts of the heap, we could safely run them in parallel. Also, given a precise
alias information, we could perform some form of typestate analysis, which
consists in checking that objects are used following a certain protocol. A
typical example is objects representing files: it is required that you first
open a file before reading from it. Such analyses require a precise alias
analysis to limit the amount of spurious warnings.

The analysis is mainly based on abstract interpretation
\cite{DBLP:conf/popl/CousotC77,DBLP:conf/popl/CousotC02}. The abstract
representation consists of graphs. Such graphs are built so that the analysis
is compositional.

\section{Contributions}
This thesis makes the following contributions:
\begin{itemize}
    \item
    We present an inter-procedural effect and alias analysis for the Scala
    programing language. This analysis works on arbitrary Scala code in the
    absence of concurrency. It is mostly inspired by the escape analysis done
    in \cite{}. We however adapted it to become an effect analysis and
    contributed the following additional features:
    \begin{itemize}
        \item A precise analysis allowing strong updates for most field
        updates.
        \item A simple recency abstraction to allow objects represented by
        allocations sites to be considered as singletons when applicable.
        \item A refinement of the allocation
        sites\cite{DBLP:conf/pldi/ChaseWZ90} along the call-stack in
        order to provide more precise analysis result in the presence of
        general factory methods.
    \end{itemize}

    \item We also provide an open source
    implementation\footnote{\url{http://github.com/colder/insane}} for the
    mentioned analysis, for which we also developed:
    \begin{itemize}
        \item A backend storage system for intermediate graph results using a
        database.
        \item A simple way to describe the effects of unanalyzable methods, such
        as the ones from the Java library.
    \end{itemize}
\end{itemize}

\section{Organization of this thesis}
The rest of this thesis is organized as follows: Then,
Chapter~\ref{chap:overview} gives a quick overview of the tool, followed by
in-depth description of the initial analysis phases.
Chapter~\ref{chap:pointer} describes in full details the pointer and effect
analysis phase.  In Chapter~\ref{chap:implementation}, we describe some
technical implementation details. Chapter~\ref{chap:related} describes previous
work done in the field of pointer and effect analysis. We then conclude in
Chapter~\ref{chap:conclusion} with some ideas for future work.
