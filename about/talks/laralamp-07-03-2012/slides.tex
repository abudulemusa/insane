\documentclass[hyperref={pdfpagelabels=false}]{beamer}

\usepackage{listings}
\usepackage{algorithm}
\usepackage{algorithmicx}
\usepackage{algpseudocode}

\usetheme{Warsaw}
\setbeamercovered{transparent}
\setbeamertemplate{footline}[page number]
\setbeamertemplate{navigation symbols}{} %remove navigation symbols
\setbeamertemplate{bibliography entry title}{}

\newcommand{\codestyle}{\small\sffamily}

% "define" Scala
\lstdefinelanguage{scala}{
  alsoletter={@,=,>},
  morekeywords={abstract, case, catch, class, def, do, else, extends, false, final, finally, for, if, implicit, import, match, new, null, object, 
override, package, private, protected, requires, return, sealed, super, this, throw, trait, try, true, type, val, var, while, with, yield, domain, 
postcondition, precondition,invariant, constraint, assert, forAll, in, _, return, @generator, ensure, require, holds, ensuring,=>},
  sensitive=true,
  morecomment=[l]{//},
  morecomment=[s]{/*}{*/},
  morestring=[b]"
}
\lstset{
%  frame=tb,
  language=scala,
%  aboveskip=3mm,
%  belowskip=3mm,
%  lineskip=-0.1em,
  showstringspaces=false,
  columns=fullflexible,
  mathescape=true,
  numbers=none,
  numberstyle=\tiny,
  basicstyle=\codestyle
} 

\newcommand\highlight[1]{\color{red}{#1}}

\begin{document}
\title{Insane: Precise and Compositional Effect Analysis of Higher-Order Programs}
\author{Etienne Kneuss}
\date{\today}

\nocite{*}

\institute[EPFL]{
Laboratory for Automated Reasoning and Analysis \\
School of Computer and Communication Sciences\\
EPFL\\
}

\begin{frame}
    \titlepage
\end{frame}

\section*{Outline}
\begin{frame}
    \frametitle{Outline}
    \tableofcontents
\end{frame}

\section{Introduction}

\begin{frame}[label=overview]
    \begin{figure}[t]
        \includegraphics[width=60mm]{../../../logo.png}\\
        Interprocedural Static Analysis Engine for Scala
    \end{figure}

    \begin{itemize}
        \item Precise pointer and effect analysis
            \begin{itemize}
                \item Interprocedural
                \item Flow sensitive
                \item No annotations required
                \item Compositional
                \item Flexible representation of effects
                \item Aimed at higher-order programs
            \end{itemize}
    \end{itemize}
\end{frame}

\begin{frame}
\frametitle{End Goal}
    Statically compute compositional summaries of
    \begin{enumerate}
        \item memory effects
        \item aliasing relations
    \end{enumerate}

    \vspace{25pt}
    For each method, we want to compute a summary that, given an abstract heap
    before the call, will allow the computation of a sound but precise abstract
    heap after the call.
\end{frame}

\begin{frame}
\frametitle{Abstract Heaps}
  \begin{columns}
    \begin{column}{0.4\textwidth}

        Abstract Heaps: $H_a$
        \begin{itemize}
            \item Nodes are objects
            \item Edges are fields
        \end{itemize}

        \vspace{10pt}
        Method Summary:
        $S_a : H_a \mapsto H_a$


    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{figure}[t]
            \includegraphics[height=60mm]{images/aheap.png}\\
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\subsection{Representation}

\begin{frame}[fragile]
\frametitle{Simple Example}
  \begin{columns}
    \begin{column}{0.4\textwidth}
\begin{lstlisting}
class LList(var data: Int,
           var next: LList)

object Test {
  def run(ll1: LList,
          ll2: LList): LList = {
    val old = ll1.next
    ll1.next = ll2
    old
  }
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{figure}[t]
            %\includegraphics[width=60mm]{images/e1.png}\\
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Simple Example}
  \begin{columns}
    \begin{column}{0.4\textwidth}
\begin{lstlisting}
class LList(var data: Int,
           var next: LList)

object Test {
  def run(ll1: LList,
          ll2: LList): LList = {
    val old = ll1.next
    ll1.next = ll2
    old
  }
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{figure}[t]
        \includegraphics[width=60mm]{images/e1.png}\\
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Simple Example}
  \begin{columns}
    \begin{column}{0.4\textwidth}
\begin{lstlisting}
object Test {
  def run(ll1: LList,
          ll2: LList): LList = {
    val old = ll1.next
    ll1.next = ll2
    old
  }

  def test() = {
    val ll = new LList(0,
              new LList(1,
               null))
    run(ll, ll)
    ll
  }
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{figure}[t]
        //TODO GRAPH BEFORE, GRAPH AFTER
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\subsection{First Chalenge}

\begin{frame}[fragile]
\frametitle{First Challenge}
\begin{lstlisting}
class LList(var data: Int,
           var next: LList) {
  def map(f: Int => Int) = {
    LList(f(data), if (next != null) next.map(f) else null)
  }
}
\end{lstlisting}
\end{frame}

\begin{frame}[fragile]
\frametitle{First Challenge}
\begin{lstlisting}[escapechar=\%]
class LList(var data: Int,
           var next: LList) {
  def map(f: %\highlight{F1[Int, Int]}%) = {
    LList(%\highlight{f.apply(data)}%, if (next != null) next.map(f) else null)
  }
}
\end{lstlisting}

    \vspace{10pt}
    How can we summarize \emph{map()}?

    \pause
    \begin{itemize}
        \item Two alternatives:
        \begin{enumerate}
            \item Consider all defined targets
            \item Delay the analysis of \emph{f.apply}
        \end{enumerate}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
\frametitle{First Challenge}
    \textbf{Considering all defined targets:}\\
    \vspace{5pt}
    Bad idea: it kills precision.

    \vspace{25pt}
    \pause

    \textbf{Delay the analysis of \emph{f.apply}:}\\
    \vspace{5pt}
    Interesting, since \emph{f} is usually rapidly refined:

\begin{lstlisting}[escapechar=\%]
    def plop(l: List) = {
      l.map({ i => i + 1})
    }
\end{lstlisting}

 But how can we record the call left dangling in the effect summary?
\end{frame}

\begin{frame}[fragile]
\frametitle{First Challenge: Delaying}
\begin{lstlisting}[escapechar=\%]
class C(var field1: C, var field2: C);
\end{lstlisting}

\begin{lstlisting}[escapechar=\%]
def plop1(obj: C, f: C => Unit) = {
    obj.field1 = ..
    %\highlight{f(obj)}%
}

def plop2(obj: C, f: C => Unit) = {
    %\highlight{f(obj)}%
    obj.field1 = ..
}
\end{lstlisting}
    \begin{figure}
    \center{
    $S_a(plop1) =^? S_a(plop2)$
\pause
\\
\textbf{no}, we require flow-sensitivity
\pause
    \\
    $\Rightarrow$ we need a new representation
    }
    \end{figure}
\end{frame}

\section{New Representation}
\begin{frame}[fragile]
\frametitle{New Effect Representation}
    Instead of generating simple effect graphs we:
    \begin{enumerate}
        \item Start from the CFG,
        \item analyze what we can,
        \item reduce the CFG by introducing \emph{effect statements} sumarizing
        blocks of analyzed statements
    \end{enumerate}

    \vspace{15pt}

    We obtain a CFG where only dangling method calls remain! We use this
    reduced CFG as summary.

\end{frame}

\begin{frame}[fragile]
\frametitle{Example}
  \begin{columns}
    \begin{column}{0.4\textwidth}
\begin{lstlisting}[escapechar=\%]
class LList(var data: Int,
           var next: LList) {
  def mapHead(f: F1[Int, Int]) = {
    new LList(f.apply(data), next)
  }
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{figure}[t]
        \includegraphics[height=60mm]{images/e3.png}\\
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example}
  \begin{figure}[t]
    \begin{center}
    \includegraphics[width=90mm]{images/e4.png}\\
    \end{center}
  \end{figure}
\end{frame}

\begin{frame}[fragile]
\frametitle{Example}
  \begin{columns}
    \begin{column}{0.4\textwidth}
\begin{lstlisting}[escapechar=\%]
class LList(var data: Int,
           var next: LList) {
  def mapHead(f: F1[Int, Int]) = {
    new LList(f.apply(data), next)
  }
}

object Test {
  def test(l: LList) = {
    l.mapHead({ i => 42 })
  }
}
\end{lstlisting}
    \end{column}
    \begin{column}{0.6\textwidth}
      \begin{figure}[t]
        \begin{center}
        \includegraphics[width=60mm]{images/e5.png}\\
        Test.test()
        \end{center}
      \end{figure}
    \end{column}
  \end{columns}
\end{frame}

\begin{frame}[fragile]
\frametitle{New Effect Representation: Flexibility}
    keep some calls, others not
\end{frame}

\begin{frame}[fragile]
\frametitle{New Effect Representation: Heuristics}
    when to keep call, when to merge
\end{frame}

\begin{frame}[fragile]
\frametitle{New Effect Representation: Difficulties}
    fixpoint, stuff
\end{frame}

\section{Conclusions}
\subsection{Conclusions}

\begin{frame}[fragile]
\frametitle{New Effect Representation}
    Instead of generating simple effect graphs we:
    \begin{enumerate}
        \item Start from the CFG,
        \item analyze what we can,
        \item reduce the CFG by introducing \emph{effect statements} sumarizing
        blocks of analyzed statements
    \end{enumerate}

    \vspace{15pt}

    We obtain a CFG where only dangling method calls remain! We use this
    reduced CFG as summary.

\end{frame}

\subsection{Future Work}

\begin{frame}[fragile]
\frametitle{Future Work}


\end{frame}
\end{document}
